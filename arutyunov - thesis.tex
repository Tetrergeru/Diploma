\documentclass[14pt]{mmcs_article}
\usepackage[russian]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb}

%\graphicspath{{images/}}%путь к рисункам

\begin{document}

\include{TitulBak}

\renewcommand{\contentsname}{Оглавление}

\tableofcontents

%=======================
\newpage
\addcontentsline{toc}{section}{Постановка задачи}

\section*{Постановка задачи}


В постановке задачи коротко (по пунктам) указывается, что необходимо сделать в рамках работы. Раздел <<Постановка задачи>> должен соответствовать заданию на курсовую или выпускную квалификационную работу, подписанному научным руководителем.


%=======================
\newpage
\addcontentsline{toc}{section}{Введение}
\section*{Введение}

В описании современных стандартов передачи данных много внимания уделено контролю за ошибками, неизбежно возникающими в любом канале связи. В теории кодирования применяют много различных подходов к проблеме коррекции подобных ошибок. Обычно для этого вместе с последовательностью данных передают последовательность проверочных битов, которые позволяют обнаружить и даже исправить ошибочно переданные сигналы.

Каждому проверочному биту соответствует набор информационных битов, в соответствии с которыми вычисляется его значение. От того, как задано это соотношение, сильно зависит эффективность процесса передачи данных, поэтому целесообразно искать алгоритмы, максимально эффективно соотносящие поток информации с данными для проверки.

Методы построения таких соотношений, используемые в крупных компаниях, попадают под соглашения о неразглашении, поэтому широко известны только методы, связанные с полным перебором возможных матриц.

Далее мы рассмотрим подходы к решению данной задачи, основанные на рассмотрении графов с определённой структурой.

%=======================
\newpage
\section{Основные понятия и утверждения}\label{dsfs}

Определение 1. \textsl{Графом Таннера} будем называть двудольный неориентированный граф.

Вершины из одной доли графа Таннера соответствуют информационным битам, а вершины из другой ~--- проверочным. Вершины из этих долей называют \textsl{информационными} и \textsl{проверочными} соответственно. Рёбра же определяют взаимосвязь между этими двумя потоками данных.

Определение 2. \textsl{Обхватом графа} называют длину его минимального цикла.

Отметим, что обхват любого графа Таннера является чётным.

Известно, что на практике для кодирования эффективнее использовать графы с большим обхватом.

Определение 3. Граф Таннера называется \textsl{(m, n)-регулярным}, если степень каждой проверочной вершины равна m, а степень каждой информационной вершины равна n.

Определение 4. Будем называть граф Таннера \textsl{почти (3, n)-регулярным}, если большая часть информационных вершин имеет степень 3, а степень остальных не меньше двух.

На практике обычно используют (3, n)-регулярные или почти (3, n)-регулярные графы.

%=======================
\newpage
\section{Графы с регулярной структурой}

\subsection{Определение}

Графом с регулярной структурой, будем называть двудольный граф, который сотоит из заданного количества одинаковых компонент, между которыми строятся дуги таким образом, что граф изоморфен сам себе по отображению, циклически смещающему все вершины $i$-той компоненты в аналогичные вершины $i + 1 \pmod K$-той компоненты, где $K$ ~--- общее количество компонент в графе.

%TODO починить стрелку 
Граф с регулярной структурой задаётся четвёркой $\langle c, i, K \in \mathbb{N}, f: \mathbb{Z} \rightarrow \{ \mathbb{Z} \times \mathbb{N} \} \rangle$, где $c$ ~--- это количество проверочных вершин в компоненте, $i$ ~--- количество информационных вершин в компоненте, $K$ ~--- количество компонент, а $f$ ~--- отображение, по которому строятся дуги. Оно сопоставляет номера проверочных вершины внутри компоненты в относительные номера компонент и номера информационных вершин внутри компонент, с которыми связана дуга.

На рис. \ref{stud:fig:1} изображён граф с регулярными структурами, заданный четвёркой $\langle 1, 2, 4, f: f(1) = \{ (0, 1), (0, 2), (-1, 2), (1, 1) \} \rangle$

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4]{Fig_1.png}
  \caption{ Граф с регулярной структурой. Компоненты пронумерованы от 1 до 4. Вершины помечены в формате \{номер компонетны\}.\{i, если вершина информационная, с, если проверочная\}\{номер вершины\} }\label{stud:fig:1}
\end{figure}

При анализе таких графов можно опустить параметр $K$, считая его достаточно большим, а затем при использовании подобрать его исходя из практических требований к размеру графа. Поэтому далее будем говорить о том, что регулярный граф задаётся тройкой $\langle c, i, f \rangle$.

\subsection{Представление графов с регулярной структурой}

Тройку $\langle c, i, f \rangle$, которой задаётся граф с регулярной структурой, можно наглядно изобразить в виде компоненты, в которой проведены дуги проведены в соответствующие информационные вершины в этой же самой компоненте. Дуги следует пометить относительным номером компоненты, с которой она связана.

На рис. \ref{stud:fig:2} изображено подобное представление графа, соответствующего тройке $\langle 1, 2, f: f(1) = \{ (0, 1), (0, 2), (-1, 2), (1, 1) \} \rangle$

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4]{Fig_2.png}
  \caption{ Упрощённое представление графа с регулярной структурой. }
  \label{stud:fig:2}
\end{figure}

\subsection{Поиск циклов в графах с регулярной структурой}

Так как основная задача при построении таких графов ~--- контроллировать длину минимального цикла, рассмотрим алгоритм поиска циклов в графе с регулярной структурой, заданном тройкой $\langle c, i, f \rangle$.

\textbf{Лемма 1.}

Если в графе с регулярными структурами есть цикл длины $t$, то через одну из проверочных вершин первой компоненты проходит цикл длины $t$.

\textbf{Доказательство.}

Любой цикл в двудольном графе проходит через какую-то проверочную вершину. Обозначим номер компоненты $d$, а индекс проверочной вершины внутри компоненты через $j$. Из определения графа с регулярными компонентами, следует, что он изоморфен сам себе по отображению, циклически сдвигающему все вершины каждой $i$-той компоненты в $i - d \pmod K$-тую компоненту. Следовательно, существует цикл длины $t$, проходящий через $j$-тую проверочную вершину первой компоненты.

\qed

Из леммы 1 следует, что чтобы показать, что минимальный цикл в графе имеет длину $t$, достаточно убедиться, что через проверочные вершины одной компоненты не проходят циклы короче, чем $t$.

\textbf{Алгоритм 1.} 

В листинге \ref{stud:lst:1} приведён алгоритм поиска циклов проходящих через $j$-тую проверочную вершину. Для того, чтобы найти кратчайший цикл во всём графе нужно применить алгоритм ко всем проверочным вершинам компоненты.

\textbf{Теорема 1.}

Приведённый алгоритм находит кратчайший цикл, проходящий через заданную проверочную вершину.

\textbf{Доказательство.}

Если вершина в неком поколении $\phi$ помечена неким числом $n$, значит кратчайший путь до этой вершины в компоненте $n$ от заданной проверочной вершины равен $\phi$, так как фактически осуществляется поиск в ширину, который находит кратчайшие пути. Если существует два кратчайших пути длмны $\phi$ без общих вершин (кроме начальной и конечной) до вершины, алгоритм завершается.

Если существует кратчайший цикл длины $t$, значит в этом цикле есть вершина $v$, до которой существует два пути длины $t / 2$, в которых нет совпадающий вершин. Так как цикл кратчайший, то пути до вершины $v$ короче, чем $t / 2$ нет. Если есть два пути длины $t / 2$, у которых есть общие вершины (кроме начальной и конечной), то они образуют цикл длины, меньшей, чем $t$, следовательно таких путей нет.

Таким образом, алгоритм обязательно найдёт кратчайший цикл.

\qed

\begin{lstlisting}[caption={Алгоритм поиска циклов}, label=stud:lst:1]
//   Возвращает длину самого короткого цикла, проходящего через j- тую
// проверочную вершину компоненты или -1, если циклов меньше или равных
// max-cycle не найдено
fn find-cycle(j, max-cycle) {
    // Начинаем работу с нулевого поколения
    generation = 0;
    //   Словарь где ключами выступают вершины и поколения,
    // а значения - множества меток.
    //   Метки соответствуют пройденному пути.
    //   Изначально j- тая проверочная вершина помечена нулём.
    labels = { (control(j), generation): { 0 } };
    для всех вершин vertex в текущем поколении {
        generation += 1;
        для всех дуг edge, соединённых с vertex {
            для всех меток label на вершине vertex
            в текущем поколении {
                next-vertex = вершина, с которой соединена дуга;
                //   Если проходим по дуге снизу-вверх,
                // берём сдвиг с обратным знаком
                shift = edge.label*(vertex проверочная ? 1 : -1);
                shifted-label = label + shift;

                если next-vertex уже помечена shifted-label
                в одном из предыдущих поколений поколении:
                    continue;

                если next-vertex уже помечена shifted-label 
                в текущем поколении:
                    return generation * 2;
                
                пометить next-vertex shifted-label
                в текущем поколении
            }
        }
        если generation >= max-cycle / 2:
            return -1;
    }
}
\end{lstlisting}

На рис. \ref{stud:fig:3} изображён пример работы алгоритма. Для удобства поколения пометок обозначены цветами. Нулевое поколение ~--- синим, первое ~--- зелёным, второе ~--- голубым, третье ~--- розовым, четвёртое ~--- жёлтым. Совпадающие метки в четвёртом поколении обведены красными рамками. Алгоритм легко доработать так, чтобы он возвращао список вершин, из которых состоит цикл. Для этого следует к пометкам добавить ссылку на родительскую вершину и затем, когда цикл найден, вернуться по ссылкам назад, собирая список вершин. На рис. \ref{stud:fig:4} изображён один из циклов, найденных в результате работы алгоритма. 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{Fig_3.png}
  \caption{ Пример работы алгоритма поиска циклов. }
  \label{stud:fig:3}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4]{Fig_4.png}
  \caption{ Пример цикла, найденного алгоритмом поиска циклов. }
  \label{stud:fig:4}
\end{figure}

На рис. \ref{stud:fig:5} изображён пример работы алгоритма на графе, дуги которого имеют неизвестные сдвиги, обозначенные буквами $a$, $b$ и $c$. Видно, что вне зависимости от значений переменных найден цикл-шестёрка.

\textbf{Замечание.}

(3,n)-регулярные графы с регулярными структурами и обхватом больше шести нельзя построить, если в компоненте только одна проверочная вершина, так как всякий такой граф будет содержать циклы-шестёрки, проходящие через первую информационную вершину.
 
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{Fig_5.png}
  \caption{ Пример поиска цикла на графе с неизвестными сдвигами. }
  \label{stud:fig:5}
\end{figure}
   
%=======================
\newpage
\addcontentsline{toc}{section}{Построение графа с регулярной структурой и заданным минимальным циклом}
\section*{Построение графа с регулярной структурой и заданным минимальным циклом.}

\textbf{Алгоритм 2.}

Для того, чтобы построить граф с заданным обхватом $t$, обозначим сдвиги на дугах как $x_1$, $x_2$, ..., $x_e$. Сделаем $t/2$ итераций алгоритма поиска циклов. Если алгоритм нашёл цикл, то выбранная структура компоненты не позволяет построить граф с заданным обхватом, необходимо увеличить количенство проверочных вершин.

Множество всех меток, полученных в результате работы алгоритма, разделяем по поколению и вершине на подмножества $U(v, d)$, где $v$ пробегает множество вершин, а $d$ ~--- множество поколений. По полученным подмножествам составляем систему неравенств вида $U(v, d)[i] \neq U(v,d)[j] \forall i \neq j; v; d$.

Находим решение полученной системы неравенств, строим граф со сдвигами дуг равными значениям полученного решения. В данном графе размер минимального цикла будет больше или равен $t$. 

\textbf{Теорема.}

В результате карректного завершения работы алгоритма 2 получается граф с обхватом больше или равным требуемому.

\textbf{Доказательство.}

Допустим, мы нашли решение системы неравенств, равное $(\alpha_1, \alpha_2, ..., \alpha_e)$. Построим граф по этому решению. Делаем $t/2$ итераций алгоритма поиска циклов. Так как система неравенств гарантирует, что метки в одной вершине и одном поколении отличаются, алгоритм не завершается. Следовательно обхват графа больше или равен $t$.

\qed

\textbf{Замечание.}

При использовании алгоритма 2 удобно в качестве пометок использовать вместо сумм вида $a_1 x_1 + a_2 x_2 + ... + a_e x_e$ кортежи вида $(a_1, a_2, ..., a_e)$. Неравенство вида $a_1 x_1 + ... + z_e x_e \neq b_1 x_1 + ... + b_e x_e$ можно записывать в виде кортежа $(a_1 - b_1, ..., a_e - b_e)$. Такой кортеж можно домножать на константу, что эквивалентно домножению на константу обеих сторон неравенства. 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{Fig_6.png}
  \caption{ Пример поиска цикла на графе с неизвестными сдвигами. }
  \label{stud:fig:6}
\end{figure}

%=======================
\newpage
\addcontentsline{toc}{section}{Заключение}
\section*{Заключение}


%=======================
\newpage

\addcontentsline{toc}{section}{Литература}
\renewcommand{\refname}{\centering \textbf{Литература}}


\end{document}
% ----------------------------------------------------------------


\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b]
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
extendedchars=true,
commentstyle=\color{mygreen},    % comment style
stringstyle=\bf,
commentstyle=\ttfamily\itshape,
keepspaces=true % пробелы между русскими буквами
aboveskip=3mm,
belowskip=3mm

}


\renewcommand\NAT@bibsetnum[1]{\settowidth\labelwidth{\@biblabel{#1}}%
   \setlength{\leftmargin}{\bibindent}\addtolength{\leftmargin}{\dimexpr\labelwidth+\labelsep\relax}%
   \setlength{\itemindent}{-\bibindent+\fivecharsapprox}%
   \setlength{\listparindent}{\itemindent}
\setlength{\itemsep}{\bibsep}\setlength{\parsep}{\z@}%
   \ifNAT@openbib
     \addtolength{\leftmargin}{\bibindent}%
     \setlength{\itemindent}{-\bibindent}%
     \setlength{\listparindent}{\itemindent}%
     \setlength{\parsep}{0pt}%
   \fi
}
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}.}
